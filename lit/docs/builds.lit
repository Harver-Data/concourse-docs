\title{Builds}{builds}

\use-plugin{concourse-docs}

A build is an execution of a \italic{build plan}, which is either

\list{
  configured as a sequence of \reference{steps}{steps} in a \reference{jobs}{job}
}{
  generated by the \reference{checker} to run a \reference{resource-check}
}{
  submitted directly to Concourse as a one-off build via \reference{fly-execute}
}

Containers and volumes are created as \reference{get-step}s,
\reference{put-step}s, and \reference{task-step}s run. When a build completes
successfully, these containers go away.

A failed build's containers and volumes are kept around so that you can debug
the build via \reference{fly-intercept}. If the build belongs to a
\reference{jobs}{job}, the containers will go away when the next build starts.
If the build is a one-off, its containers will be removed immediately, so make
sure you intercept while it's running, if you want to debug.

\table-of-contents

\section{
  \title{Rerunning a Build}{build-rerunning}

  Concourse supports build rerunning, which means to run a new build using the
  exact same set of input versions as the original build. There are two ways to
  rerun a build: through the web UI on the builds page and through the
  \reference{fly-rerun-build}.

  When a build is rerun, it will create a new build using the name of the
  original build with the rerun number appended to it, e.g. \code{3.1} for the
  first rerun of build \code{3}.

  Rerun builds are ordered chronologically after the original build, rather
  than becoming a new "latest" build. Similarly, when the scheduler is
  resolving \reference{schema.get.passed}{\code{passed}} constraints
  that reference a job with rerun builds, those rerun builds are
  processed in this same order. This ensures that the versions, which made it
  through a rerun build, do not become the new "latest versions". Instead, they
  act as if the original build had succeeded at its point in the build history.

  This may sound a little confusing, but the summary is that reruns should
  behave as if they replace the original failed build.

  \section{
    \title{Current caveats with rerunning}

    The current implementation of rerunning is an early iteration with one key
    limitation: a rerun build will use the \bold{current state of the job
    config}, instead of running the exact build plan the original build ran
    with.

    This means that if the \reference{schema.job.plan} has changed in a way
    that is backwards-incompatible, the rerun build may error. For example, if
    a new input is added, its version will not be available as the original
    build did not use it.

    There are future plans to have reruns execute the exact build plan from the
    original build. If you are interested in tracking the progress for the
    second pass at rerunning builds - or contributing yourself! - the project
    epic is called \link{Build Lifecycle
    View}{https://project.concourse-ci.org/projects/MDc6UHJvamVjdDM3NjI5MTk=}.
  }
}

